{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Inicio \u00b6 Taller de desarrollo de aplicaciones m\u00f3vil con React Native \u00b6 Este taller forma parte de las actividades del Aula de Software Libre de la Universidad de C\u00f3rdoba . Agradecimientos \u00b6 Este taller ha sido realizado por: Francisco Javier Molina Prieto","title":"Inicio"},{"location":"#inicio","text":"","title":"Inicio"},{"location":"#taller-de-desarrollo-de-aplicaciones-movil-con-react-native","text":"Este taller forma parte de las actividades del Aula de Software Libre de la Universidad de C\u00f3rdoba .","title":"Taller de desarrollo de aplicaciones m\u00f3vil con React Native"},{"location":"#agradecimientos","text":"Este taller ha sido realizado por: Francisco Javier Molina Prieto","title":"Agradecimientos"},{"location":"aplying-styles/","text":"Aplicando estilos a componentes \u00b6 Con React Native, dise\u00f1as tu aplicaci\u00f3n usando JavaScript. Todos los componentes principales aceptan una prop llamada style . Las propiedades y valores de estilo suelen coincidir con las propiedades de CSS en desarrollo web, excepto que los nombres se escriben en camelCase, por ejemplo, backgroundColor en lugar de background-color . La prop style puede ser un simple objeto JavaScript. Eso es lo que hemos visto en algunos ejemplos anteriores. Tambi\u00e9n podemos pasar un array de estilos; el \u00faltimo estilo del array tiene prioridad sobre el resto, por lo que puede usarse para heredar estilos. A medida que un componente crece en complejidad, es recomendable usar StyleSheet.create para definir varios estilos en un solo sitio. Observa el siguiente ejemplo: import React from \"react\" ; import { StyleSheet , Text , View } from \"react-native\" ; const LotsOfStyles = () => { return ( < View style = { styles . container } > < Text style = { styles . red } > just red </ Text > < Text style = { styles . bigBlue } > just bigBlue </ Text > < Text style = {[ styles . bigBlue , styles . red ]} > bigBlue , then red </ Text > < Text style = {[ styles . red , styles . bigBlue ]} > red , then bigBlue </ Text > </ View > ); }; const styles = StyleSheet . create ({ container : { marginTop : 50 , }, bigBlue : { color : \"blue\" , fontWeight : \"bold\" , fontSize : 30 , }, red : { color : \"red\" , }, }); export default LotsOfStyles ; Tambi\u00e9n podemos hacer que un componente acepte una prop style que afecte a subcomponentes del mismo, lo que se conoce como estilos en cascada.","title":"Aplicando estilos a componentes"},{"location":"aplying-styles/#aplicando-estilos-a-componentes","text":"Con React Native, dise\u00f1as tu aplicaci\u00f3n usando JavaScript. Todos los componentes principales aceptan una prop llamada style . Las propiedades y valores de estilo suelen coincidir con las propiedades de CSS en desarrollo web, excepto que los nombres se escriben en camelCase, por ejemplo, backgroundColor en lugar de background-color . La prop style puede ser un simple objeto JavaScript. Eso es lo que hemos visto en algunos ejemplos anteriores. Tambi\u00e9n podemos pasar un array de estilos; el \u00faltimo estilo del array tiene prioridad sobre el resto, por lo que puede usarse para heredar estilos. A medida que un componente crece en complejidad, es recomendable usar StyleSheet.create para definir varios estilos en un solo sitio. Observa el siguiente ejemplo: import React from \"react\" ; import { StyleSheet , Text , View } from \"react-native\" ; const LotsOfStyles = () => { return ( < View style = { styles . container } > < Text style = { styles . red } > just red </ Text > < Text style = { styles . bigBlue } > just bigBlue </ Text > < Text style = {[ styles . bigBlue , styles . red ]} > bigBlue , then red </ Text > < Text style = {[ styles . red , styles . bigBlue ]} > red , then bigBlue </ Text > </ View > ); }; const styles = StyleSheet . create ({ container : { marginTop : 50 , }, bigBlue : { color : \"blue\" , fontWeight : \"bold\" , fontSize : 30 , }, red : { color : \"red\" , }, }); export default LotsOfStyles ; Tambi\u00e9n podemos hacer que un componente acepte una prop style que afecte a subcomponentes del mismo, lo que se conoce como estilos en cascada.","title":"Aplicando estilos a componentes"},{"location":"env-setup/","text":"Preparaci\u00f3n del entorno de desarrollo \u00b6 Si eres nuevo en el desarrollo de aplicaciones m\u00f3vil, la forma m\u00e1s sencilla de comenzar es con Expo CLI. Expo es un conjunto de herramientas construido alrededor de React Native y, si bien tiene muchas caracter\u00edsticas , la caracter\u00edstica m\u00e1s relevante es que permite crear una aplicaci\u00f3n de React Native en escasos minutos. Solo necesitar\u00e1s una versi\u00f3n reciente de Node.js y un tel\u00e9fono o emulador. Si quieres, tambi\u00e9n puedes probar React Native directamente en tu navegador web antes de instalar cualquier herramienta, a trav\u00e9s de Snack . Si ya est\u00e1s familiarizado con el desarrollo m\u00f3vil, es posible que prefieras utilizar React Native CLI. Esta opci\u00f3n requiere tener instalados Xcode o Android Studio. Si ya tienes una de estas herramientas instalada, deber\u00edas poder empezar a trabajar en unos minutos. Si no tienes ninguna de estas herramientas instalada, tardar\u00e1s aproximadamente una hora en tener todo instalado y configurado. En este taller, nos centraremos en Expo CLI, aunque en la documentaci\u00f3n de React Native , puedes ver la gu\u00eda para utilizar React Native CLI, si prefieres esta opci\u00f3n. Preparaci\u00f3n del entorno con Expo CLI \u00b6 En caso de tener la versi\u00f3n de Node 12 LTS o una m\u00e1s reciente, puedes usar npm para instalar el Expo CLI a trav\u00e9s de una terminal, ejecutando el siguiente comando: npm install -g expo-cli Despu\u00e9s, con el siguiente comando, crear\u00e1s un proyecto de React Native llamado \"MiProyecto\". Elige otro nombre si lo prefieres: expo init AwesomeProject cd AwesomeProject npm start # you can also use: expo start Con el primer comando crearemos el proyecto, con el segundo entraremos a la carpeta del mismo, generado con el comando anterior, y con npm start levantaremos un servidor local con nuestra aplicaci\u00f3n.","title":"Preparaci\u00f3n del entorno de desarrollo"},{"location":"env-setup/#preparacion-del-entorno-de-desarrollo","text":"Si eres nuevo en el desarrollo de aplicaciones m\u00f3vil, la forma m\u00e1s sencilla de comenzar es con Expo CLI. Expo es un conjunto de herramientas construido alrededor de React Native y, si bien tiene muchas caracter\u00edsticas , la caracter\u00edstica m\u00e1s relevante es que permite crear una aplicaci\u00f3n de React Native en escasos minutos. Solo necesitar\u00e1s una versi\u00f3n reciente de Node.js y un tel\u00e9fono o emulador. Si quieres, tambi\u00e9n puedes probar React Native directamente en tu navegador web antes de instalar cualquier herramienta, a trav\u00e9s de Snack . Si ya est\u00e1s familiarizado con el desarrollo m\u00f3vil, es posible que prefieras utilizar React Native CLI. Esta opci\u00f3n requiere tener instalados Xcode o Android Studio. Si ya tienes una de estas herramientas instalada, deber\u00edas poder empezar a trabajar en unos minutos. Si no tienes ninguna de estas herramientas instalada, tardar\u00e1s aproximadamente una hora en tener todo instalado y configurado. En este taller, nos centraremos en Expo CLI, aunque en la documentaci\u00f3n de React Native , puedes ver la gu\u00eda para utilizar React Native CLI, si prefieres esta opci\u00f3n.","title":"Preparaci\u00f3n del entorno de desarrollo"},{"location":"env-setup/#preparacion-del-entorno-con-expo-cli","text":"En caso de tener la versi\u00f3n de Node 12 LTS o una m\u00e1s reciente, puedes usar npm para instalar el Expo CLI a trav\u00e9s de una terminal, ejecutando el siguiente comando: npm install -g expo-cli Despu\u00e9s, con el siguiente comando, crear\u00e1s un proyecto de React Native llamado \"MiProyecto\". Elige otro nombre si lo prefieres: expo init AwesomeProject cd AwesomeProject npm start # you can also use: expo start Con el primer comando crearemos el proyecto, con el segundo entraremos a la carpeta del mismo, generado con el comando anterior, y con npm start levantaremos un servidor local con nuestra aplicaci\u00f3n.","title":"Preparaci\u00f3n del entorno con Expo CLI"},{"location":"height-and-width/","text":"Ancho y alto de un componente \u00b6 La altura y el ancho de un componente determinan su tama\u00f1o en la pantalla. Dimensiones fijas \u00b6 La forma general de establecer las dimensiones de un componente es agregando estilos fijos width y height . Todas las dimensiones en React Native no tienen unidades y representan p\u00edxeles independientes de la densidad, es decir, p\u00edxeles que son independientes de las dimensiones de la pantalla. import React from \"react\" ; import { View } from \"react-native\" ; const FixedDimensionsBasics = () => { return ( < View > < View style = {{ width : 50 , height : 50 , backgroundColor : \"powderblue\" , }} /> < View style = {{ width : 100 , height : 100 , backgroundColor : \"skyblue\" , }} /> < View style = {{ width : 150 , height : 150 , backgroundColor : \"steelblue\" , }} /> </ View > ); }; export default FixedDimensionsBasics ; Esta forma de indicar el ancho y alto se usa cuando queremos que un componente siempre tenga ese alto y ancho especificados, y que no se calcule en base al tama\u00f1o de la pantalla. Dimensiones flex (flexibles) \u00b6 Usa flex en el estilo de un componente para que el componente se expanda y encoja din\u00e1micamente seg\u00fan el espacio disponible. Es com\u00fan usar flex: 1 , que indica a un componente que llene todo el espacio disponible, compartido uniformemente entre otros componentes con el mismo padre. Cuanto mayor sea el valor de flex de un componente, mayor ser\u00e1 la proporci\u00f3n de espacio que ocupar\u00e1 este en comparaci\u00f3n con sus elementos hermanos. import React from \"react\" ; import { View } from \"react-native\" ; const FlexDimensionsBasics = () => { return ( // Try removing the ` flex : 1 ` on the parent View . // The parent will not have dimensions , so the children can 't expand. // What if you add ` height : 300 ` instead of ` flex : 1 `? < View style = {{ flex : 1 }} > < View style = {{ flex : 1 , backgroundColor : \"powderblue\" }} /> < View style = {{ flex : 2 , backgroundColor : \"skyblue\" }} /> < View style = {{ flex : 3 , backgroundColor : \"steelblue\" }} /> </ View > ); }; export default FlexDimensionsBasics ; Dimensiones en porcentajes \u00b6 Si quieres llenar una cierta proporci\u00f3n de la pantalla, pero prefieres no usar flex , puedes usar valores porcentuales en el estilo del componente. Al igual que las dimensiones flexibles, las dimensiones porcentuales requieren un padre con un tama\u00f1o definido. import React from \"react\" ; import { View } from \"react-native\" ; const PercentageDimensionsBasics = () => { // Try removing the ` height : '100%' ` on the parent View . // The parent will not have dimensions , so the children can 't expand. return ( < View style = {{ height : \"100%\" }} > < View style = {{ height : \"15%\" , backgroundColor : \"powderblue\" , }} /> < View style = {{ width : \"66%\" , height : \"35%\" , backgroundColor : \"skyblue\" , }} /> < View style = {{ width : \"33%\" , height : \"50%\" , backgroundColor : \"steelblue\" , }} /> </ View > ); }; export default PercentageDimensionsBasics ;","title":"Ancho y alto de un componente"},{"location":"height-and-width/#ancho-y-alto-de-un-componente","text":"La altura y el ancho de un componente determinan su tama\u00f1o en la pantalla.","title":"Ancho y alto de un componente"},{"location":"height-and-width/#dimensiones-fijas","text":"La forma general de establecer las dimensiones de un componente es agregando estilos fijos width y height . Todas las dimensiones en React Native no tienen unidades y representan p\u00edxeles independientes de la densidad, es decir, p\u00edxeles que son independientes de las dimensiones de la pantalla. import React from \"react\" ; import { View } from \"react-native\" ; const FixedDimensionsBasics = () => { return ( < View > < View style = {{ width : 50 , height : 50 , backgroundColor : \"powderblue\" , }} /> < View style = {{ width : 100 , height : 100 , backgroundColor : \"skyblue\" , }} /> < View style = {{ width : 150 , height : 150 , backgroundColor : \"steelblue\" , }} /> </ View > ); }; export default FixedDimensionsBasics ; Esta forma de indicar el ancho y alto se usa cuando queremos que un componente siempre tenga ese alto y ancho especificados, y que no se calcule en base al tama\u00f1o de la pantalla.","title":"Dimensiones fijas"},{"location":"height-and-width/#dimensiones-flex-flexibles","text":"Usa flex en el estilo de un componente para que el componente se expanda y encoja din\u00e1micamente seg\u00fan el espacio disponible. Es com\u00fan usar flex: 1 , que indica a un componente que llene todo el espacio disponible, compartido uniformemente entre otros componentes con el mismo padre. Cuanto mayor sea el valor de flex de un componente, mayor ser\u00e1 la proporci\u00f3n de espacio que ocupar\u00e1 este en comparaci\u00f3n con sus elementos hermanos. import React from \"react\" ; import { View } from \"react-native\" ; const FlexDimensionsBasics = () => { return ( // Try removing the ` flex : 1 ` on the parent View . // The parent will not have dimensions , so the children can 't expand. // What if you add ` height : 300 ` instead of ` flex : 1 `? < View style = {{ flex : 1 }} > < View style = {{ flex : 1 , backgroundColor : \"powderblue\" }} /> < View style = {{ flex : 2 , backgroundColor : \"skyblue\" }} /> < View style = {{ flex : 3 , backgroundColor : \"steelblue\" }} /> </ View > ); }; export default FlexDimensionsBasics ;","title":"Dimensiones flex (flexibles)"},{"location":"height-and-width/#dimensiones-en-porcentajes","text":"Si quieres llenar una cierta proporci\u00f3n de la pantalla, pero prefieres no usar flex , puedes usar valores porcentuales en el estilo del componente. Al igual que las dimensiones flexibles, las dimensiones porcentuales requieren un padre con un tama\u00f1o definido. import React from \"react\" ; import { View } from \"react-native\" ; const PercentageDimensionsBasics = () => { // Try removing the ` height : '100%' ` on the parent View . // The parent will not have dimensions , so the children can 't expand. return ( < View style = {{ height : \"100%\" }} > < View style = {{ height : \"15%\" , backgroundColor : \"powderblue\" , }} /> < View style = {{ width : \"66%\" , height : \"35%\" , backgroundColor : \"skyblue\" , }} /> < View style = {{ width : \"33%\" , height : \"50%\" , backgroundColor : \"steelblue\" , }} /> </ View > ); }; export default PercentageDimensionsBasics ;","title":"Dimensiones en porcentajes"},{"location":"layout-with-flexbox/","text":"Dise\u00f1o con Flexbox \u00b6 Un componente puede especificar el dise\u00f1o de sus hijos usando el algoritmo Flexbox. Flexbox est\u00e1 dise\u00f1ado para proporcionar un dise\u00f1o uniforme en diferentes tama\u00f1os de pantalla. Es normal que se utilice una combinaci\u00f3n de flexDirection , alignItems y justifyContent para lograr la disposici\u00f3n correcta. Veamos que significan estas propiedades. Flex Direction \u00b6 flexDirection establece la direcci\u00f3n en la que se distribuyen los elementos secundarios de un nodo padre. Tambi\u00e9n se conoce como el eje principal. El eje transversal es el eje perpendicular al eje principal. Esta propiedad tiene los siguientes posibles valores: column ( valor por defecto ) Alinea a los hijos de arriba a abajo. row Alinea a los hijos de izquierda a derecha. column-reverse Alinea a los hijos de abajo hacia arriba. row-reverse Alinea a los hijos de derecha a izquierda. Layout Direction \u00b6 direction especifica la direcci\u00f3n en la que se deben distribuir los elementos secundarios y el texto en una jerarqu\u00eda de elementos. Tambi\u00e9n afecta a qu\u00e9 se refieren los valores start y end . De forma predeterminada, React Native tiene la direcci\u00f3n LTR. Con este valor, start se refiere a la izquierda y end a la derecha. LTR ( valor por defecto ) El texto y los elementos secundarios se distribuyen de izquierda a derecha. El margen y el relleno aplicados al inicio de un elemento se aplican en el lado izquierdo. RTL El texto y los elementos secundarios se distribuyen de derecha a izquierda. El margen y el relleno aplicados al inicio de un elemento se aplican en el lado derecho. Justify Content \u00b6 justifyContent indica c\u00f3mo alinear a los hijos dentro del eje principal de su contenedor. Por ejemplo, puedes usar esta propiedad para centrar a un hijo horizontalmente dentro de un contenedor que tiene la propiedad flexDirection establecida en row , o verticalmente dentro de un contenedor con la propiedad flexDirection establecida en column . flex-start ( valor predeterminado ) Alinea los elementos secundarios de un contenedor al inicio del eje principal del contenedor. flex-end Alinea los hijos de un contenedor al final del eje principal del contenedor. center Alinea los hijos de un contenedor en el centro del eje principal del contenedor. space-between Separa uniformemente a los hijos a lo largo del eje principal del contenedor, distribuyendo el espacio restante entre los hijos . space-around Separa uniformemente a los hijos a lo largo del eje principal del contenedor, distribuyendo el espacio restante alrededor de los hijos . En comparaci\u00f3n con space-between , al usar space-around se distribuir\u00e1 el espacio antes del primer hijo y despu\u00e9s del \u00faltimo hijo. space-evenly Distribuye uniformemente a los hijos dentro del contenedor de alineaci\u00f3n a lo largo del eje principal. El espacio entre cada par de elementos adyacentes, el espacio entre el inicio y el primer elemento, y el espacio entre el final y el \u00faltimo elemento, es exactamente el mismo. Align Items \u00b6 alignItems indica c\u00f3mo alinear a los hijos a lo largo del eje transversal de su contenedor. Es muy similar a justifyContent pero en lugar de aplicarse al eje principal, se aplica al eje transversal. stretch ( valor predeterminado ) Estira los elementos secundarios de un contenedor para que coincidan con el height del eje transversal del contenedor. flex-start Alinea los hijos de un contenedor al inicio del eje transversal del contenedor. flex-end Alinea los hijos de un contenedor al final del eje transversal del contenedor. center Alinea los hijos de un contenedor en el centro del eje transversal del contenedor. baseline Alinea los hijos de un contenedor a lo largo de una l\u00ednea de base com\u00fan. Se puede establecer que los hijos individuales sean la l\u00ednea de base de referencia para sus padres. Align Self \u00b6 alignSelf tiene las mismas opciones y efectos que alignItems , pero en lugar de afectar a los hijos dentro de un contenedor, puede aplicarse esta propiedad a un solo hijo para cambiar su alineaci\u00f3n dentro de su padre. alignSelf anula cualquier opci\u00f3n establecida por el padre con alignItems . Flex Wrap \u00b6 La propiedad flexWrap se establece en los contenedores y controla lo que sucede cuando los hijos desbordan el tama\u00f1o del contenedor a lo largo del eje principal. De forma predeterminada, los ni\u00f1os se ven obligados a entrar en una sola l\u00ednea (lo que puede encoger elementos). Si se permite el envoltorio o wrapping, los elementos se envuelven en varias l\u00edneas a lo largo del eje principal si es necesario. Al envolver l\u00edneas, se puede utilizar alignContent para especificar c\u00f3mo se colocan las l\u00edneas en el contenedor. Align Content \u00b6 alignContent indica la distribuci\u00f3n de las l\u00edneas a lo largo del eje transversal. Esto solo tiene efecto cuando los elementos se envuelven en varias l\u00edneas usando flexWrap . flex-start ( valor por defecto ) Alinea las l\u00edneas envueltas al inicio del eje transversal del contenedor. flex-end Alinea las l\u00edneas envueltas al final del eje transversal del contenedor. stretch Estira las l\u00edneas envueltas para que coincidan con la altura del eje transversal del contenedor. center Alinea las l\u00edneas envueltas en el centro del eje transversal del contenedor. space-between Las l\u00edneas envueltas se distribuyen uniformemente a trav\u00e9s del eje transversal del contenedor, distribuyendo el espacio restante entre las l\u00edneas. space-around Las l\u00edneas envueltas se distribuyen uniformemente a trav\u00e9s del eje transversal del contenedor, distribuyendo el espacio restante alrededor de las l\u00edneas. A diferencia de space-between , al usar space-around el espacio se distribuir\u00e1 al principio de la primera l\u00ednea y al final de la \u00faltima l\u00ednea. Echa un vistazo al Playground de Yoga Layout , donde puedes probar todas estas propiedades y sus posibles valores. Existen algunas propiedades m\u00e1s de Flexbox que pueden ser de utilidad en determinados casos, puedes obtener m\u00e1s informaci\u00f3n sobre estas en la documentaci\u00f3n oficial .","title":"Dise\u00f1o con Flexbox"},{"location":"layout-with-flexbox/#diseno-con-flexbox","text":"Un componente puede especificar el dise\u00f1o de sus hijos usando el algoritmo Flexbox. Flexbox est\u00e1 dise\u00f1ado para proporcionar un dise\u00f1o uniforme en diferentes tama\u00f1os de pantalla. Es normal que se utilice una combinaci\u00f3n de flexDirection , alignItems y justifyContent para lograr la disposici\u00f3n correcta. Veamos que significan estas propiedades.","title":"Dise\u00f1o con Flexbox"},{"location":"layout-with-flexbox/#flex-direction","text":"flexDirection establece la direcci\u00f3n en la que se distribuyen los elementos secundarios de un nodo padre. Tambi\u00e9n se conoce como el eje principal. El eje transversal es el eje perpendicular al eje principal. Esta propiedad tiene los siguientes posibles valores: column ( valor por defecto ) Alinea a los hijos de arriba a abajo. row Alinea a los hijos de izquierda a derecha. column-reverse Alinea a los hijos de abajo hacia arriba. row-reverse Alinea a los hijos de derecha a izquierda.","title":"Flex Direction"},{"location":"layout-with-flexbox/#layout-direction","text":"direction especifica la direcci\u00f3n en la que se deben distribuir los elementos secundarios y el texto en una jerarqu\u00eda de elementos. Tambi\u00e9n afecta a qu\u00e9 se refieren los valores start y end . De forma predeterminada, React Native tiene la direcci\u00f3n LTR. Con este valor, start se refiere a la izquierda y end a la derecha. LTR ( valor por defecto ) El texto y los elementos secundarios se distribuyen de izquierda a derecha. El margen y el relleno aplicados al inicio de un elemento se aplican en el lado izquierdo. RTL El texto y los elementos secundarios se distribuyen de derecha a izquierda. El margen y el relleno aplicados al inicio de un elemento se aplican en el lado derecho.","title":"Layout Direction"},{"location":"layout-with-flexbox/#justify-content","text":"justifyContent indica c\u00f3mo alinear a los hijos dentro del eje principal de su contenedor. Por ejemplo, puedes usar esta propiedad para centrar a un hijo horizontalmente dentro de un contenedor que tiene la propiedad flexDirection establecida en row , o verticalmente dentro de un contenedor con la propiedad flexDirection establecida en column . flex-start ( valor predeterminado ) Alinea los elementos secundarios de un contenedor al inicio del eje principal del contenedor. flex-end Alinea los hijos de un contenedor al final del eje principal del contenedor. center Alinea los hijos de un contenedor en el centro del eje principal del contenedor. space-between Separa uniformemente a los hijos a lo largo del eje principal del contenedor, distribuyendo el espacio restante entre los hijos . space-around Separa uniformemente a los hijos a lo largo del eje principal del contenedor, distribuyendo el espacio restante alrededor de los hijos . En comparaci\u00f3n con space-between , al usar space-around se distribuir\u00e1 el espacio antes del primer hijo y despu\u00e9s del \u00faltimo hijo. space-evenly Distribuye uniformemente a los hijos dentro del contenedor de alineaci\u00f3n a lo largo del eje principal. El espacio entre cada par de elementos adyacentes, el espacio entre el inicio y el primer elemento, y el espacio entre el final y el \u00faltimo elemento, es exactamente el mismo.","title":"Justify Content"},{"location":"layout-with-flexbox/#align-items","text":"alignItems indica c\u00f3mo alinear a los hijos a lo largo del eje transversal de su contenedor. Es muy similar a justifyContent pero en lugar de aplicarse al eje principal, se aplica al eje transversal. stretch ( valor predeterminado ) Estira los elementos secundarios de un contenedor para que coincidan con el height del eje transversal del contenedor. flex-start Alinea los hijos de un contenedor al inicio del eje transversal del contenedor. flex-end Alinea los hijos de un contenedor al final del eje transversal del contenedor. center Alinea los hijos de un contenedor en el centro del eje transversal del contenedor. baseline Alinea los hijos de un contenedor a lo largo de una l\u00ednea de base com\u00fan. Se puede establecer que los hijos individuales sean la l\u00ednea de base de referencia para sus padres.","title":"Align Items"},{"location":"layout-with-flexbox/#align-self","text":"alignSelf tiene las mismas opciones y efectos que alignItems , pero en lugar de afectar a los hijos dentro de un contenedor, puede aplicarse esta propiedad a un solo hijo para cambiar su alineaci\u00f3n dentro de su padre. alignSelf anula cualquier opci\u00f3n establecida por el padre con alignItems .","title":"Align Self"},{"location":"layout-with-flexbox/#flex-wrap","text":"La propiedad flexWrap se establece en los contenedores y controla lo que sucede cuando los hijos desbordan el tama\u00f1o del contenedor a lo largo del eje principal. De forma predeterminada, los ni\u00f1os se ven obligados a entrar en una sola l\u00ednea (lo que puede encoger elementos). Si se permite el envoltorio o wrapping, los elementos se envuelven en varias l\u00edneas a lo largo del eje principal si es necesario. Al envolver l\u00edneas, se puede utilizar alignContent para especificar c\u00f3mo se colocan las l\u00edneas en el contenedor.","title":"Flex Wrap"},{"location":"layout-with-flexbox/#align-content","text":"alignContent indica la distribuci\u00f3n de las l\u00edneas a lo largo del eje transversal. Esto solo tiene efecto cuando los elementos se envuelven en varias l\u00edneas usando flexWrap . flex-start ( valor por defecto ) Alinea las l\u00edneas envueltas al inicio del eje transversal del contenedor. flex-end Alinea las l\u00edneas envueltas al final del eje transversal del contenedor. stretch Estira las l\u00edneas envueltas para que coincidan con la altura del eje transversal del contenedor. center Alinea las l\u00edneas envueltas en el centro del eje transversal del contenedor. space-between Las l\u00edneas envueltas se distribuyen uniformemente a trav\u00e9s del eje transversal del contenedor, distribuyendo el espacio restante entre las l\u00edneas. space-around Las l\u00edneas envueltas se distribuyen uniformemente a trav\u00e9s del eje transversal del contenedor, distribuyendo el espacio restante alrededor de las l\u00edneas. A diferencia de space-between , al usar space-around el espacio se distribuir\u00e1 al principio de la primera l\u00ednea y al final de la \u00faltima l\u00ednea. Echa un vistazo al Playground de Yoga Layout , donde puedes probar todas estas propiedades y sus posibles valores. Existen algunas propiedades m\u00e1s de Flexbox que pueden ser de utilidad en determinados casos, puedes obtener m\u00e1s informaci\u00f3n sobre estas en la documentaci\u00f3n oficial .","title":"Align Content"},{"location":"project-structure/","text":"Estructura del proyecto \u00b6 Si hemos creado nuestro proyecto utilizando Expo CLI, la estructura de carpetas de nuestro proyecto deber\u00eda ser similar a la siguiente: Tendremos los siguientes ficheros y carpetas: .expo-shared: Carpeta con ficheros de configuraci\u00f3n de expo, que no nos interesa tocar de momento. assets: Carpeta que contendr\u00e1 cualquier tipo de recurso (im\u00e1genes, audios, fuentes, ...) que necesitemos utilizar en nuestra aplicaci\u00f3n. node_modules: Carpeta que contiene todas las dependencias de nuestro proyecto. Necesitamos esta carpeta en nuestro proyecto para que todo funcione correctamente. Si instalamos cualquier paquete de terceros (que lo haremos), ser\u00e1 aqu\u00ed donde se aloje. .gitignore: Fichero que ayuda a Git a decidir de qu\u00e9 ficheros debe realizar un seguimiento para el control de versiones. \u00bfA\u00fan no sabes qu\u00e9 es Git? \u00a1Echa un vistazo a nuestro taller de Git ! Te aseguro que cuando descubras esta herramienta no podr\u00e1s despegarte de ella. App.js: Este el fichero con el c\u00f3digo que muestra nuestra aplicaci\u00f3n al ser levantada con el comando start que hemos ejecutado previamente. Inicialmente habr\u00e1 un componente funcional llamado App que contiene una plantilla (template) de c\u00f3digo en JSX. app.json: Contiene informaci\u00f3n sobre nuestro proyecto, su nombre, sus plataformas soportadas, etc. package.json: Es el fichero utilizado por node para realizar el seguimiento de las dependencias del proyecto. Si a\u00f1adimos alguna dependencia al proyecto, se reflejar\u00e1 en este fichero para que, en caso de que alguien se clone el proyecto, pueda instalar estas dependencias con npm install , ya que la carpeta node_modules nunca deber\u00eda subirse a Git. Adem\u00e1s de las dependencias, este fichero tambi\u00e9n suele contener scripts que facilitan la ejecuci\u00f3n de algunos comandos que suelen ejecutarse frecuentemente.","title":"Estructura del proyecto"},{"location":"project-structure/#estructura-del-proyecto","text":"Si hemos creado nuestro proyecto utilizando Expo CLI, la estructura de carpetas de nuestro proyecto deber\u00eda ser similar a la siguiente: Tendremos los siguientes ficheros y carpetas: .expo-shared: Carpeta con ficheros de configuraci\u00f3n de expo, que no nos interesa tocar de momento. assets: Carpeta que contendr\u00e1 cualquier tipo de recurso (im\u00e1genes, audios, fuentes, ...) que necesitemos utilizar en nuestra aplicaci\u00f3n. node_modules: Carpeta que contiene todas las dependencias de nuestro proyecto. Necesitamos esta carpeta en nuestro proyecto para que todo funcione correctamente. Si instalamos cualquier paquete de terceros (que lo haremos), ser\u00e1 aqu\u00ed donde se aloje. .gitignore: Fichero que ayuda a Git a decidir de qu\u00e9 ficheros debe realizar un seguimiento para el control de versiones. \u00bfA\u00fan no sabes qu\u00e9 es Git? \u00a1Echa un vistazo a nuestro taller de Git ! Te aseguro que cuando descubras esta herramienta no podr\u00e1s despegarte de ella. App.js: Este el fichero con el c\u00f3digo que muestra nuestra aplicaci\u00f3n al ser levantada con el comando start que hemos ejecutado previamente. Inicialmente habr\u00e1 un componente funcional llamado App que contiene una plantilla (template) de c\u00f3digo en JSX. app.json: Contiene informaci\u00f3n sobre nuestro proyecto, su nombre, sus plataformas soportadas, etc. package.json: Es el fichero utilizado por node para realizar el seguimiento de las dependencias del proyecto. Si a\u00f1adimos alguna dependencia al proyecto, se reflejar\u00e1 en este fichero para que, en caso de que alguien se clone el proyecto, pueda instalar estas dependencias con npm install , ya que la carpeta node_modules nunca deber\u00eda subirse a Git. Adem\u00e1s de las dependencias, este fichero tambi\u00e9n suele contener scripts que facilitan la ejecuci\u00f3n de algunos comandos que suelen ejecutarse frecuentemente.","title":"Estructura del proyecto"},{"location":"react-fundamentals/","text":"Fundamentos b\u00e1sicos de React \u00b6 React Native se ejecuta en React, una librer\u00eda de c\u00f3digo abierto muy popular, utilizada para la creaci\u00f3n de interfaces de usuario con JavaScript, y de la cual tenemos un peque\u00f1o taller en el canal. Para sacar el m\u00e1ximo provecho de React Native, necesitamos entender conceptos b\u00e1sicos de React. Cubriremos brevemente los siguientes conceptos fundamentales de React: Componentes JSX Props State (estado) Si quieres adentrarte m\u00e1s en estos y otros conceptos de React, echa un vistazo a la documentaci\u00f3n oficial . JSX \u00b6 React y React Native utilizan JSX, una sint\u00e1xis que permite escribir elementos dentro de JavaScript, como el siguiente ejemplo: const AnyCat = () => { return ( <Text> Hello, I am a cat! </Text> ); } JSX es al fin y al cabo JavaScript, por lo que puede usar variables dentro de este. En el siguiente ejemplo, declararemos un name para un gato. const Cat = () => { const name = \"Maru\"; return ( <Text> Hello, I am {name}! </Text> ); } Los dos ejemplos anteriores son lo que se conocen como componentes, en los que indagaremos a continuaci\u00f3n. Componentes \u00b6 Los componentes son piezas de c\u00f3digo independientes y reutilizables que funcionan de manera similar a funciones de JavaScript, aceptando entradas arbitrarias llamadas Props, y devolviendo a React elementos que describen lo que deber\u00eda aparecer por pantalla. Estos componentes se dividen en Componentes de Clase y Componentes Funcionales. El siguiente ejemplo, se trata de un componente funcional. import React from 'react' ; import { Text } from 'react-native' ; const Cat = () => { return ( < Text > Hello , I am your cat ! </ Text > ); } export default Cat ; Los componentes de clase tienden a ser algo m\u00e1s detallados de lo necesario. import React , { Component } from 'react' ; import { Text } from 'react-native' ; class Cat extends Component { render () { return ( < Text > Hello , I am your cat ! </ Text > ); } } export default Cat ; Como se puede observar, en ambos casos necesitamos importar React, que nos permitir\u00e1 utilizar c\u00f3digo JSX. Props \u00b6 Props es la abreviatura de propiedades . Las props te permiten personalizar componentes de React. En el siguiente ejemplo, pasaremos una propiedad name al componente Cat a trav\u00e9s de un componente Cafe. import React from 'react' ; import { Text , View } from 'react-native' ; const Cat = ( props ) => { return ( < View > < Text > Hello , I am { props . name } ! </ Text > </ View > ); } const CatsCafe = () => { return ( < View > < Cat name = \"Maru\" /> < Cat name = \"Jellylorum\" /> < Cat name = \"Spot\" /> </ View > ); } export default CatsCafe ; El componente Cafe consta de una vista que renderiza tres gatos, cada uno con su propio nombre. La mayor\u00eda de componentes core de React Native tambi\u00e9n disponen de props para personalizarlos a tu gusto. Por ejemplo, el componente Image dispone de una propiedad source para indicar la imagen que debe mostrar. <Image source= {{ uri : \"https://reactnative.dev/docs/assets/p_cat1.png\" }} style= {{ width : 200 , height : 200 }} /> Image tiene un gran n\u00famero de propiedades, incluyendo style , que acepta un objeto de JavaScript que contiene pares propiedad-valor relacionados con el dise\u00f1o del elemento. Echa un vistazo a la propiedad style y a las llaves dobles que contienen a las propiedades width and height. En JSX, los valores de JavaScript son referenciados con {} . Esto es muy \u00fatil cuando estamos pasando algo distinto de un string como una propiedad, como un array o un n\u00famero. <Cat food={[\"fish\", \"kibble\"]} age={2} /> . Sin embargo, los objetos de JavaScript tambi\u00e9n son marcados utilizando llaves: {width: 200, height: 200} . Por ello, para pasar un objeto de JS en JSX, debes contener el objeto en otro par de llaves, como en el ejemplo anterior. Puedes construir much\u00edsimas cosas utilizando props y los componentes core de React Native, como Text , Image o View , pero para crear algo interactivo, necesitar\u00e1s un state o estado. State \u00b6 El state de un componente funciona como su almac\u00e9n de datos personal. Es \u00fatil para manejar datos que cambian a lo largo del tiempo, o que dependen de una interacci\u00f3n del usuario. \u00a1El state brinda a tus componentes de su propia memoria! Como regla general, usa props para configurar el renderizado de un componente. Utiliza el state para realizar un seguimiento de cualquier dato en un componente que esperas que cambie a lo largo del tiempo. Observa el siguiente ejemplo de un componente de clase con state: import React , { Component } from \"react\" ; import { Button , Text , View } from \"react-native\" ; class Cat extends Component { state = { isHungry : true }; render () { return ( < View > < Text > I am { this . props . name }, and I am { this . state . isHungry ? \" hungry\" : \" full\" } ! </ Text > < Button onPress = {() => { this . setState ({ isHungry : false }); }} disabled = { ! this . state . isHungry } title = { this . state . isHungry ? \"Pour me some milk, please!\" : \"Thank you!\" } /> </ View > ); } } En resumen, se trata de un componente Cat con un state booleano isHungry cuyo valor por defecto es true. Cuando pulsamos en el bot\u00f3n, se ejecuta la funci\u00f3n indicada en la prop onPress del mismo, estableciendo la propiedad a false, cambiando el valor de las props title y disabled . \u00bfPor qu\u00e9 se ha utilizado un componente de clase para el ejemplo del estado? \u00bfNo eran menos legibles y demasiado detallados? Esto es correcto, pero tiene su explicaci\u00f3n. Hasta la llegada de los hooks de React, los componentes de clase eran los \u00fanicos que nos permit\u00edan manejar un estado y un ciclo de vida en nuestros componentes. Sin embargo, desde la aparici\u00f3n de estos, es posible tener un estado en componentes funcionales, cuya sem\u00e1ntica es mucho m\u00e1s simple y limpia. Un hook es una peque\u00f1a funci\u00f3n que permite a un componente \"engancharse\" (\"hook into\") a caracter\u00edsticas de React. Por ejemplo, useState es un Hook que te permite a\u00f1adir state a un componente funcional. El siguiente ejemplo, es exactamente igual al anterior, pero utilizando un componente funcional: import React , { useState } from \"react\" ; import { Button , Text , View } from \"react-native\" ; const Cat = ( props ) => { const [ isHungry , setIsHungry ] = useState ( true ); return ( < View > < Text > I am { props . name }, and I am { isHungry ? \"hungry\" : \"full\" } ! </ Text > < Button onPress = {() => { setIsHungry ( false ); }} disabled = { ! isHungry } title = { isHungry ? \"Pour me some milk, please!\" : \"Thank you!\" } /> </ View > ); } Al llamar al hook useState, hacemos dos cosas: Crear una variable de state con un valor inicial. En el ejemplo anterior, la variable es isHungry y su valor inicial es true . Crea una funci\u00f3n para reestablecer el valor de esa variable, setIsHungry . En este taller, por tanto, nos centraremos en los componentes funcionales, ya que, adem\u00e1s de sus ventajas frente a los componentes de clase, haremos uso de alg\u00fan otro Hook de React.","title":"Fundamentos b\u00e1sicos de React"},{"location":"react-fundamentals/#fundamentos-basicos-de-react","text":"React Native se ejecuta en React, una librer\u00eda de c\u00f3digo abierto muy popular, utilizada para la creaci\u00f3n de interfaces de usuario con JavaScript, y de la cual tenemos un peque\u00f1o taller en el canal. Para sacar el m\u00e1ximo provecho de React Native, necesitamos entender conceptos b\u00e1sicos de React. Cubriremos brevemente los siguientes conceptos fundamentales de React: Componentes JSX Props State (estado) Si quieres adentrarte m\u00e1s en estos y otros conceptos de React, echa un vistazo a la documentaci\u00f3n oficial .","title":"Fundamentos b\u00e1sicos de React"},{"location":"react-fundamentals/#jsx","text":"React y React Native utilizan JSX, una sint\u00e1xis que permite escribir elementos dentro de JavaScript, como el siguiente ejemplo: const AnyCat = () => { return ( <Text> Hello, I am a cat! </Text> ); } JSX es al fin y al cabo JavaScript, por lo que puede usar variables dentro de este. En el siguiente ejemplo, declararemos un name para un gato. const Cat = () => { const name = \"Maru\"; return ( <Text> Hello, I am {name}! </Text> ); } Los dos ejemplos anteriores son lo que se conocen como componentes, en los que indagaremos a continuaci\u00f3n.","title":"JSX"},{"location":"react-fundamentals/#componentes","text":"Los componentes son piezas de c\u00f3digo independientes y reutilizables que funcionan de manera similar a funciones de JavaScript, aceptando entradas arbitrarias llamadas Props, y devolviendo a React elementos que describen lo que deber\u00eda aparecer por pantalla. Estos componentes se dividen en Componentes de Clase y Componentes Funcionales. El siguiente ejemplo, se trata de un componente funcional. import React from 'react' ; import { Text } from 'react-native' ; const Cat = () => { return ( < Text > Hello , I am your cat ! </ Text > ); } export default Cat ; Los componentes de clase tienden a ser algo m\u00e1s detallados de lo necesario. import React , { Component } from 'react' ; import { Text } from 'react-native' ; class Cat extends Component { render () { return ( < Text > Hello , I am your cat ! </ Text > ); } } export default Cat ; Como se puede observar, en ambos casos necesitamos importar React, que nos permitir\u00e1 utilizar c\u00f3digo JSX.","title":"Componentes"},{"location":"react-fundamentals/#props","text":"Props es la abreviatura de propiedades . Las props te permiten personalizar componentes de React. En el siguiente ejemplo, pasaremos una propiedad name al componente Cat a trav\u00e9s de un componente Cafe. import React from 'react' ; import { Text , View } from 'react-native' ; const Cat = ( props ) => { return ( < View > < Text > Hello , I am { props . name } ! </ Text > </ View > ); } const CatsCafe = () => { return ( < View > < Cat name = \"Maru\" /> < Cat name = \"Jellylorum\" /> < Cat name = \"Spot\" /> </ View > ); } export default CatsCafe ; El componente Cafe consta de una vista que renderiza tres gatos, cada uno con su propio nombre. La mayor\u00eda de componentes core de React Native tambi\u00e9n disponen de props para personalizarlos a tu gusto. Por ejemplo, el componente Image dispone de una propiedad source para indicar la imagen que debe mostrar. <Image source= {{ uri : \"https://reactnative.dev/docs/assets/p_cat1.png\" }} style= {{ width : 200 , height : 200 }} /> Image tiene un gran n\u00famero de propiedades, incluyendo style , que acepta un objeto de JavaScript que contiene pares propiedad-valor relacionados con el dise\u00f1o del elemento. Echa un vistazo a la propiedad style y a las llaves dobles que contienen a las propiedades width and height. En JSX, los valores de JavaScript son referenciados con {} . Esto es muy \u00fatil cuando estamos pasando algo distinto de un string como una propiedad, como un array o un n\u00famero. <Cat food={[\"fish\", \"kibble\"]} age={2} /> . Sin embargo, los objetos de JavaScript tambi\u00e9n son marcados utilizando llaves: {width: 200, height: 200} . Por ello, para pasar un objeto de JS en JSX, debes contener el objeto en otro par de llaves, como en el ejemplo anterior. Puedes construir much\u00edsimas cosas utilizando props y los componentes core de React Native, como Text , Image o View , pero para crear algo interactivo, necesitar\u00e1s un state o estado.","title":"Props"},{"location":"react-fundamentals/#state","text":"El state de un componente funciona como su almac\u00e9n de datos personal. Es \u00fatil para manejar datos que cambian a lo largo del tiempo, o que dependen de una interacci\u00f3n del usuario. \u00a1El state brinda a tus componentes de su propia memoria! Como regla general, usa props para configurar el renderizado de un componente. Utiliza el state para realizar un seguimiento de cualquier dato en un componente que esperas que cambie a lo largo del tiempo. Observa el siguiente ejemplo de un componente de clase con state: import React , { Component } from \"react\" ; import { Button , Text , View } from \"react-native\" ; class Cat extends Component { state = { isHungry : true }; render () { return ( < View > < Text > I am { this . props . name }, and I am { this . state . isHungry ? \" hungry\" : \" full\" } ! </ Text > < Button onPress = {() => { this . setState ({ isHungry : false }); }} disabled = { ! this . state . isHungry } title = { this . state . isHungry ? \"Pour me some milk, please!\" : \"Thank you!\" } /> </ View > ); } } En resumen, se trata de un componente Cat con un state booleano isHungry cuyo valor por defecto es true. Cuando pulsamos en el bot\u00f3n, se ejecuta la funci\u00f3n indicada en la prop onPress del mismo, estableciendo la propiedad a false, cambiando el valor de las props title y disabled . \u00bfPor qu\u00e9 se ha utilizado un componente de clase para el ejemplo del estado? \u00bfNo eran menos legibles y demasiado detallados? Esto es correcto, pero tiene su explicaci\u00f3n. Hasta la llegada de los hooks de React, los componentes de clase eran los \u00fanicos que nos permit\u00edan manejar un estado y un ciclo de vida en nuestros componentes. Sin embargo, desde la aparici\u00f3n de estos, es posible tener un estado en componentes funcionales, cuya sem\u00e1ntica es mucho m\u00e1s simple y limpia. Un hook es una peque\u00f1a funci\u00f3n que permite a un componente \"engancharse\" (\"hook into\") a caracter\u00edsticas de React. Por ejemplo, useState es un Hook que te permite a\u00f1adir state a un componente funcional. El siguiente ejemplo, es exactamente igual al anterior, pero utilizando un componente funcional: import React , { useState } from \"react\" ; import { Button , Text , View } from \"react-native\" ; const Cat = ( props ) => { const [ isHungry , setIsHungry ] = useState ( true ); return ( < View > < Text > I am { props . name }, and I am { isHungry ? \"hungry\" : \"full\" } ! </ Text > < Button onPress = {() => { setIsHungry ( false ); }} disabled = { ! isHungry } title = { isHungry ? \"Pour me some milk, please!\" : \"Thank you!\" } /> </ View > ); } Al llamar al hook useState, hacemos dos cosas: Crear una variable de state con un valor inicial. En el ejemplo anterior, la variable es isHungry y su valor inicial es true . Crea una funci\u00f3n para reestablecer el valor de esa variable, setIsHungry . En este taller, por tanto, nos centraremos en los componentes funcionales, ya que, adem\u00e1s de sus ventajas frente a los componentes de clase, haremos uso de alg\u00fan otro Hook de React.","title":"State"},{"location":"react-native-paper/","text":"React Native Paper \u00b6 Los componentes core de React Native est\u00e1n muy bien y son suficientes para construir una aplicaci\u00f3n funcional con todo tipo de caracter\u00edsticas. Sin embargo, flaquean en algo que hay que tener muy en cuenta, y es que el estilo de estos componentes suele ser plano y poco llamativo, y para alguien que no haya tocado CSS lo suficiente, puede ser bastante tedioso estilar cada uno de los componentes de su aplicaci\u00f3n para intentar conseguir un resultado m\u00e1s vistoso. \u00bfLa soluci\u00f3n? React Native Paper. \u00bfQu\u00e9 es React Native Paper? \u00b6 React Native Paper es una colecci\u00f3n de componentes personalizables, multiplataforma y listos para ser usados con React Native, que siguen la gu\u00eda de dise\u00f1o Material Design de Google. Esta librer\u00eda nos provee de todo tipo de componentes, desde el m\u00e1s simple bot\u00f3n hasta una especie de carta con informaci\u00f3n e im\u00e1genes en ella. \u00bfLo mejor? Que todos los componentes disponen de varias props que permiten personalizarlos a tu gusto. Instalaci\u00f3n de dependencias y uso \u00b6 Al igual que en casos anteriores, instalaremos la librer\u00eda con un simple comando: npm install react-native-paper En caso de haber usado React Native CLI para la creaci\u00f3n del proyecto, necesitamos instalar tambi\u00e9n el pack de iconos MaterialCommunityIcons, debido a que son usados por algunos de los componentes de Paper. Como en este taller hemos utilizado Expo CLI, no es necesario que instalemos estos iconos. En caso de que tengamos un fichero babel.config.js o .babelrc , necesitaremos a\u00f1adir el preset babel-preset-expo y el plugin react-native-paper/babel . Para m\u00e1s informaci\u00f3n sobre la instalaci\u00f3n y configuraci\u00f3n inicial, visita la documentaci\u00f3n oficial de React Native Paper . Envuelve el componente ra\u00edz del proyecto en un Provider de react-native-paper . Si has creado un proyecto vanilla de React Native, suele ser recomendado agregar el Provider en el componente que se pasa a AppRegistry.registerComponent , que por lo general, est\u00e1 en el archivo index.js . En nuestro caso, que hemos creado el proyecto con Expo, a\u00f1adiremos el Provider en el fichero App.js . import * as React from \"react\" ; import { AppRegistry } from \"react-native\" ; import { Provider as PaperProvider } from \"react-native-paper\" ; import { name as appName } from \"./app.json\" ; import App from \"./src/App\" ; export default function Main () { return ( < PaperProvider > < App /> </ PaperProvider > ); } AppRegistry . registerComponent ( appName , () => Main ); El componente PaperProvider provee a todos los componentes del proyecto del tema de React Native Paper, y act\u00faa como portal para componentes que deben renderizarse en el nivel m\u00e1s alto. Personalizando el Tema por defecto \u00b6 Como hemos mencionado en la secci\u00f3n previa, hemos envuelto a nuestra aplicaci\u00f3n con un PaperProvider para dotar a los componentes del tema por defecto de Paper. Pero, \u00bfy si queremos cambiar este tema? Para esto, el Provider dispone de una prop theme a la que podemos pasarle un tema definido previamente, tal que as\u00ed: import * as React from \"react\" ; import { DefaultTheme , Provider as PaperProvider } from \"react-native-paper\" ; import App from \"./src/App\" ; const theme = { ... DefaultTheme , roundness : 2 , colors : { ... DefaultTheme . colors , primary : \"#3498db\" , accent : \"#f1c40f\" , }, }; export default function Main () { return ( < PaperProvider theme = { theme } > < App /> </ PaperProvider > ); } Echa un vistazo a la documentaci\u00f3n de React Native Paper para ver todas las propiedades por defecto en un tema. Adem\u00e1s de las propiedades por defecto, podemos crear propiedades personalizadas, extendiendo el tema por defecto. Podemos hacer esto simplemente a\u00f1adiendo una nueva propiedad en el objeto theme . const theme = { ... DefaultTheme , // Propiedad personalizada myOwnProperty : true , // Propiedad personalizada en objeto anidado colors : { myOwnColor : \"#BADA55\" , }, }; En caso de tener un proyecto en TypeScript, no funcionar\u00e1 correctamente con esta configuraci\u00f3n, pero podemos aprovechar la global augmentation y especificar las propiedades que hemos a\u00f1adido al tema. /// App . js import * as React from \"react\" ; import { DefaultTheme , Provider as PaperProvider } from \"react-native-paper\" ; import App from \"./src/App\" ; declare global { namespace ReactNativePaper { interface ThemeColors { myOwnColor : string ; } interface Theme { myOwnProperty : boolean ; } } } /// ... Resto del c\u00f3digo anterior Componentes, iconos y fuentes \u00b6 Ya tenemos todo listo para usar React Native Paper en nuestro proyecto, echa un vistazo a la variedad de componentes que ofrece la librer\u00eda y sustituye los componentes en alguna de las vistas que hemos realizado anteriormente. El cambio es bastante notorio, y la aplicaci\u00f3n tiene un aspecto mucho m\u00e1s moderno.","title":"React Native Paper"},{"location":"react-native-paper/#react-native-paper","text":"Los componentes core de React Native est\u00e1n muy bien y son suficientes para construir una aplicaci\u00f3n funcional con todo tipo de caracter\u00edsticas. Sin embargo, flaquean en algo que hay que tener muy en cuenta, y es que el estilo de estos componentes suele ser plano y poco llamativo, y para alguien que no haya tocado CSS lo suficiente, puede ser bastante tedioso estilar cada uno de los componentes de su aplicaci\u00f3n para intentar conseguir un resultado m\u00e1s vistoso. \u00bfLa soluci\u00f3n? React Native Paper.","title":"React Native Paper"},{"location":"react-native-paper/#que-es-react-native-paper","text":"React Native Paper es una colecci\u00f3n de componentes personalizables, multiplataforma y listos para ser usados con React Native, que siguen la gu\u00eda de dise\u00f1o Material Design de Google. Esta librer\u00eda nos provee de todo tipo de componentes, desde el m\u00e1s simple bot\u00f3n hasta una especie de carta con informaci\u00f3n e im\u00e1genes en ella. \u00bfLo mejor? Que todos los componentes disponen de varias props que permiten personalizarlos a tu gusto.","title":"\u00bfQu\u00e9 es React Native Paper?"},{"location":"react-native-paper/#instalacion-de-dependencias-y-uso","text":"Al igual que en casos anteriores, instalaremos la librer\u00eda con un simple comando: npm install react-native-paper En caso de haber usado React Native CLI para la creaci\u00f3n del proyecto, necesitamos instalar tambi\u00e9n el pack de iconos MaterialCommunityIcons, debido a que son usados por algunos de los componentes de Paper. Como en este taller hemos utilizado Expo CLI, no es necesario que instalemos estos iconos. En caso de que tengamos un fichero babel.config.js o .babelrc , necesitaremos a\u00f1adir el preset babel-preset-expo y el plugin react-native-paper/babel . Para m\u00e1s informaci\u00f3n sobre la instalaci\u00f3n y configuraci\u00f3n inicial, visita la documentaci\u00f3n oficial de React Native Paper . Envuelve el componente ra\u00edz del proyecto en un Provider de react-native-paper . Si has creado un proyecto vanilla de React Native, suele ser recomendado agregar el Provider en el componente que se pasa a AppRegistry.registerComponent , que por lo general, est\u00e1 en el archivo index.js . En nuestro caso, que hemos creado el proyecto con Expo, a\u00f1adiremos el Provider en el fichero App.js . import * as React from \"react\" ; import { AppRegistry } from \"react-native\" ; import { Provider as PaperProvider } from \"react-native-paper\" ; import { name as appName } from \"./app.json\" ; import App from \"./src/App\" ; export default function Main () { return ( < PaperProvider > < App /> </ PaperProvider > ); } AppRegistry . registerComponent ( appName , () => Main ); El componente PaperProvider provee a todos los componentes del proyecto del tema de React Native Paper, y act\u00faa como portal para componentes que deben renderizarse en el nivel m\u00e1s alto.","title":"Instalaci\u00f3n de dependencias y uso"},{"location":"react-native-paper/#personalizando-el-tema-por-defecto","text":"Como hemos mencionado en la secci\u00f3n previa, hemos envuelto a nuestra aplicaci\u00f3n con un PaperProvider para dotar a los componentes del tema por defecto de Paper. Pero, \u00bfy si queremos cambiar este tema? Para esto, el Provider dispone de una prop theme a la que podemos pasarle un tema definido previamente, tal que as\u00ed: import * as React from \"react\" ; import { DefaultTheme , Provider as PaperProvider } from \"react-native-paper\" ; import App from \"./src/App\" ; const theme = { ... DefaultTheme , roundness : 2 , colors : { ... DefaultTheme . colors , primary : \"#3498db\" , accent : \"#f1c40f\" , }, }; export default function Main () { return ( < PaperProvider theme = { theme } > < App /> </ PaperProvider > ); } Echa un vistazo a la documentaci\u00f3n de React Native Paper para ver todas las propiedades por defecto en un tema. Adem\u00e1s de las propiedades por defecto, podemos crear propiedades personalizadas, extendiendo el tema por defecto. Podemos hacer esto simplemente a\u00f1adiendo una nueva propiedad en el objeto theme . const theme = { ... DefaultTheme , // Propiedad personalizada myOwnProperty : true , // Propiedad personalizada en objeto anidado colors : { myOwnColor : \"#BADA55\" , }, }; En caso de tener un proyecto en TypeScript, no funcionar\u00e1 correctamente con esta configuraci\u00f3n, pero podemos aprovechar la global augmentation y especificar las propiedades que hemos a\u00f1adido al tema. /// App . js import * as React from \"react\" ; import { DefaultTheme , Provider as PaperProvider } from \"react-native-paper\" ; import App from \"./src/App\" ; declare global { namespace ReactNativePaper { interface ThemeColors { myOwnColor : string ; } interface Theme { myOwnProperty : boolean ; } } } /// ... Resto del c\u00f3digo anterior","title":"Personalizando el Tema por defecto"},{"location":"react-native-paper/#componentes-iconos-y-fuentes","text":"Ya tenemos todo listo para usar React Native Paper en nuestro proyecto, echa un vistazo a la variedad de componentes que ofrece la librer\u00eda y sustituye los componentes en alguna de las vistas que hemos realizado anteriormente. El cambio es bastante notorio, y la aplicaci\u00f3n tiene un aspecto mucho m\u00e1s moderno.","title":"Componentes, iconos y fuentes"},{"location":"react-navigation/","text":"React Navigation \u00b6 Antes de entrar en materia con la navegaci\u00f3n a trav\u00e9s de nuestra aplicaci\u00f3n, la cual conseguiremos utilizando React Navigation, es de gran utilidad tener claro c\u00f3mo funciona la navegaci\u00f3n en un navegador web. En un navegador web, nuestro historial de navegaci\u00f3n act\u00faa como una pila de URLs. Los enlaces se crean con la etiqueta de anclaje ( <a> ) en HTML. Cuando el usuario hace clic en un enlace, la URL en la que nos encontr\u00e1bamos se env\u00eda a la pila del historial del navegador y navegamos a la p\u00e1gina enlazada. Si el usuario presiona el bot\u00f3n Atr\u00e1s, el navegador mostrar\u00e1 el elemento de la parte superior de la pila del historial, por lo que la p\u00e1gina activa pasar\u00e1 a ser la p\u00e1gina visitada anteriormente. React Native no tiene una idea incorporada de un historial global o pila de URLs como lo hace un navegador web; y es aqu\u00ed donde React Navigation entra en escena. Instalaci\u00f3n de dependencias \u00b6 Antes de nada, debemos instalar las dependencias esenciales para que React Navigation funcione correctamente. En la carpeta del proyecto, ejecuta el siguiente comando: expo install react - native - gesture - handler react - native - reanimated react - native - screens react - native - safe - area - context @react - native - community / masked - view Esto instalar\u00e1 las versiones de estas librer\u00edas compatibles con la versi\u00f3n de React Native en la que se encuentre nuestro proyecto. En React Navigation existen distintos tipos de navigators, pero en este taller nos centraremos en el Stack Navigator, que es el m\u00e1s similar al de un navegador web. Stack Navigator \u00b6 El Stack Navigator de React Navigation nos provee de un mecanismo para navegar entre las distintas vistas de nuestra aplicaci\u00f3n y gestionar un historial de navegaci\u00f3n. Si tu aplicaci\u00f3n utiliza un \u00fanico stack navigator, ser\u00eda conceptualmente similar a la forma en la que un navegador gestiona su estado de navegaci\u00f3n - tu aplicaci\u00f3n mete o saca elementos de su pila de navegaci\u00f3n a medida que el usuario interact\u00faa con esta, y esto resulta en el usuario viendo distintas vistas. La diferencia respecto a un navegador web es que el stack navigator de React Navigation est\u00e1 provisto de los gestos y animaciones que ver\u00edas en una aplicaci\u00f3n de Android o iOS al navegar entre rutas. Para diferenciar entre los navigators de React Navigation, y un navegador web, no se traducir\u00e1 el concepto navigator cuando estemos hablando del primero de estos. Instalaci\u00f3n de la librer\u00eda del stack navigator \u00b6 Las librer\u00edas que hemos instalado hasta ahora son los cimientos del resto de navigators, y cada navigator en React Navigation tiene su propia librer\u00eda. Para utilizar el stack navigator, necesitaremos instalar @react-navigation/stack , ejecutando el siguiente comando. npm install @react - navigation / stack Creaci\u00f3n de un Stack Navigator \u00b6 createStackNavigator es una funci\u00f3n que devuelve un objeto que contiene 2 propiedades: Screen y Navigator . Ambos son componentes de React que se utilizan para configurar el navigator. El Navigator debe contener elementos Screen como elementos hijo para definir la configuraci\u00f3n de rutas. NavigationContainer es un componente que administra nuestro \u00e1rbol de navegaci\u00f3n y contiene el estado de navegaci\u00f3n . Este componente debe envolver la estructura de todos los navigators. Por lo general, renderizamos este componente en la ra\u00edz de nuestra aplicaci\u00f3n, que suele ser el componente exportado desde App.js . // App . js import * as React from 'react' ; import { View , Text } from 'react-native' ; import { NavigationContainer } from '@react-navigation/native' ; import { createStackNavigator } from '@react-navigation/stack' ; function HomeScreen () { return ( < View style = {{ flex : 1 , alignItems : 'center' , justifyContent : 'center' }} > < Text > Home Screen </ Text > </ View > ); } const Stack = createStackNavigator (); function App () { return ( < NavigationContainer > < Stack . Navigator > < Stack . Screen name = \"Home\" component = { HomeScreen } /> </ Stack . Navigator > </ NavigationContainer > ); } export default App ; Si ejecutas este c\u00f3digo, ver\u00e1s una pantalla con una barra de navegaci\u00f3n vac\u00eda y un \u00e1rea de contenido gris que contiene el componente HomeScreen , definido justo antes de App. Los estilos de la barra de navegaci\u00f3n y el \u00e1rea de contenido son la configuraci\u00f3n predeterminada para un stack navigator, y aprenderemos c\u00f3mo configurarlos m\u00e1s adelante. El primer componente Screen que pasemos a nuestro stack navigator ser\u00e1 la ruta inicial . Prueba a crear un componente Details , que sea igual a Home pero cambiando el texto del contenido para diferenciarlos. A continuaci\u00f3n, crea un componente Screen y pasa el componente Details como prop. Ahora, prueba a poner este Screen en primer lugar, guarda el fichero y tu aplicaci\u00f3n deber\u00eda mostrar la vista de Details . Especificando opciones al navigator \u00b6 Cada vista en el navigator puede tener sus opciones espec\u00edficas, como el t\u00edtulo que se renderiza en el encabezado. Estas opciones pueden pasarse como una prop options para cada componente Screen : <Stack.Screen name=\"Home\" component={HomeScreen} options= {{ title : 'Overview' }} /> A veces nos interesar\u00e1 especificar las mismas opciones para todas las vistas del navigator. Para ello, podemos pasar una prop screenOptions al navigator. Pasando props adicionales \u00b6 En caso de querer pasar props personalizadas a una vista, podemos conseguirlo de dos formas: Sometimes we might want to pass additional props to a screen. We can do that with 2 approaches: Utilizar React context y envolver el navigator con un provider de contexto para pasar datos a las vistas (recomendado). Utilizar un callback de renderizado en lugar de pasar un componente como prop: <Stack.Screen name= \"Home\" > {props => <HomeScreen {...props} extraData= {someData} /> } </Stack.Screen> Navegaci\u00f3n entre vistas \u00b6 Todo bien pero...\u00bfC\u00f3mo consigo navegar entre rutas de mi aplicaci\u00f3n? Vamos a ello. En la secci\u00f3n anterior, hemos definido un stack navigator con dos rutas ( Home y Details ), pero no hemos aprendido c\u00f3mo conseguir que un usuario navegue de Home a Details (aunque s\u00ed aprendimos c\u00f3mo cambiar la ruta inicial en nuestro c\u00f3digo, pero obligar a nuestros usuarios a clonar nuestro repositorio y cambiar la ruta en el c\u00f3digo para ver otra pantalla es posiblemente una de las peores experiencias de usuario que uno podr\u00eda imaginar). Si este fuera un navegador web, podr\u00edamos escribir algo como esto: <a href= \"details.html\" > Go to Details </a> O esto: <a onClick= {() = > { window.location.href = 'details.html'; }} > Go to Details </a> Haremos algo similar, pero en lugar de utilizar un objeto global window.location , usaremos el prop navigation del cual disponen nuestros componentes Screen de manera autom\u00e1tica. Observa el siguiente ejemplo: import * as React from 'react' ; import { Button , View , Text } from 'react-native' ; import { NavigationContainer } from '@react-navigation/native' ; import { createStackNavigator } from '@react-navigation/stack' ; function HomeScreen ({ navigation }) { return ( < View style = {{ flex : 1 , alignItems : 'center' , justifyContent : 'center' }} > < Text > Home Screen </ Text > < Button title = \"Go to Details\" onPress = {() => navigation . navigate ( 'Details' )} /> </ View > ); } // ... c\u00f3digo de la secci\u00f3n anterior Veamos esto con detalle: navigation: El prop navigation es pasado en cada uno de los componentes screen del stack navigator. navigate('Details') - llamamos a la funci\u00f3n navigate de la prop navigation (los nombres son algo confusos al principio) con el nombre de la ruta a la que queremos navegar. Si llamamos a navigation.navigate con un nombre de ruta que no hemos definido en un navigator, imprimir\u00e1 un error en las builds (compilaciones) de desarrollo y no pasar\u00e1 nada en las builds de producci\u00f3n. Dicho de otra manera, solo podemos navegar a rutas que hayan sido definidas en nuestro navegador, no podemos navegar a un componente arbitrario. Entonces, ahora tenemos una pila con dos rutas: 1) la ruta Home 2) la ruta Details . \u00bfQu\u00e9 pasar\u00eda si volvi\u00e9ramos a navegar a la ruta Details , desde la vista Details ? Pongamos que el c\u00f3digo de nuestro componente Details fuera el siguiente: function DetailsScreen({ navigation }) { return ( <View style= {{ flex : 1 , alignItems : 'center' , justifyContent : 'center' }} > <Text > Details Screen </Text> <Button title= \"Go to Details... again\" onPress= {() = > navigation.navigate('Details')} /> </View> ); } Si ejecutas este c\u00f3digo, notar\u00e1s que cuando tocas \"Go to Details...again\", \u00a1no hace nada! Esto se debe a que ya estamos en la ruta de Details. La funci\u00f3n navigate significa, en realidad, \"ir a esta ruta\", y si ya est\u00e1s ah\u00ed, tiene sentido que no haga nada. Supongamos que realmente queremos agregar otra vista de Details. Esto es bastante com\u00fan en casos en los que se pasa alg\u00fan dato \u00fanico a cada ruta (m\u00e1s adelante explicaremos c\u00f3mo hacerlo). Para hacer esto, podemos cambiar navigate a push . Esto nos permite expresar la intenci\u00f3n de agregar otra ruta, independientemente del historial de navegaci\u00f3n existente. < Button title = \"Go to Details... again\" onPress = { () => navigation . push ( 'Details' ) } /> Cada vez que llamamos a push , se a\u00f1ade una nueva ruta a la pila de navegaci\u00f3n. Cuando llamamos a navigate intenta encontrar una ruta existente con el nombre especificado, y solo pushea una nueva ruta en caso de no encontrarla en la pila. El encabezado proporcionado por el stack navigator incluir\u00e1 autom\u00e1ticamente un bot\u00f3n de retroceso cuando sea posible volver desde la pantalla activa (si solo hay una pantalla en la pila de navegaci\u00f3n, no hay nada a lo que se pueda volver, por lo que no hay bot\u00f3n de retroceso). En caso de necesitar este comportamiento en alg\u00fan otro sitio, puedes usar navigation.goBack(); function DetailsScreen({ navigation }) { return ( <View style= {{ flex : 1 , alignItems : 'center' , justifyContent : 'center' }} > <Text > Details Screen </Text> <Button title= \"Go to Details... again\" onPress= {() = > navigation.push('Details')} /> <Button title= \"Go to Home\" onPress= {() = > navigation.navigate('Home')} /> <Button title= \"Go back\" onPress= {() = > navigation.goBack()} /> </View> ); } Otro caso de uso com\u00fan es querer retroceder varias pantallas, por ejemplo, si tienes varias pantallas en una pila y quieres descartarlas todas para volver a la primera pantalla. Si quisi\u00e9ramos volver a Home , podr\u00edamos hacerlo usando navigate('Home') ( \u00a1no uses push ! Pru\u00e9balo y mira la diferencia). Otra alternativa ser\u00eda utilizar navigation.popToTop() , que te devuelve a la primera pantalla de la pila. function DetailsScreen({ navigation }) { return ( <View style= {{ flex : 1 , alignItems : 'center' , justifyContent : 'center' }} > <Text > Details Screen </Text> <Button title= \"Go to Details... again\" onPress= {() = > navigation.push('Details')} /> <Button title= \"Go to Home\" onPress= {() = > navigation.navigate('Home')} /> <Button title= \"Go back\" onPress= {() = > navigation.goBack()} /> <Button title= \"Go back to first screen in stack\" onPress= {() = > navigation.popToTop()} /> </View> ); } Pasar par\u00e1metros a rutas \u00b6 Ahora que sabemos c\u00f3mo crear un stack navigator con algunas rutas, pasemos a ver c\u00f3mo podemos pasar datos a las rutas cuando navegamos hacia ellas. Hay dos pasos clave para esto: Pasar los par\u00e1metros a una ruta, contenidos en un objeto, como segundo par\u00e1metro de la funci\u00f3n navigation.navigate : navigation.navigate('RouteName', { /* los par\u00e1metros ir\u00edan aqu\u00ed here */ }) Leer los parametros en el componente de la pantalla utilizando route.params . function HomeScreen({ navigation }) { return ( <View style= {{ flex : 1 , alignItems : 'center' , justifyContent : 'center' }} > <Text > Home Screen </Text> <Button title= \"Go to Details\" onPress= {() = > { /* 1. Navigate to the Details route with params */ navigation.navigate('Details', { itemId: 86, otherParam: 'anything you want here', }); }} /> </View> ); } function DetailsScreen({ route, navigation }) { /* 2. Get the param */ const { itemId, otherParam } = route.params; return ( <View style= {{ flex : 1 , alignItems : 'center' , justifyContent : 'center' }} > <Text > Details Screen </Text> <Text> itemId: {JSON.stringify(itemId)} </Text> <Text> otherParam: {JSON.stringify(otherParam)} </Text> <Button title= \"Go to Details... again\" onPress= {() = > navigation.push('Details', { itemId: Math.floor(Math.random() * 100), }) } /> <Button title= \"Go to Home\" onPress= {() = > navigation.navigate('Home')} /> <Button title= \"Go back\" onPress= {() = > navigation.goBack()} /> </View> ); } Las pantallas tambi\u00e9n pueden actualizar sus par\u00e1metros, al igual que pueden actualizar su estado. el m\u00e9todo navigation.setParams permite actualizar los par\u00e1metros de una pantalla. navigation.setParams({ query: 'someText', }) Consulta la documentaci\u00f3n oficial para obtener m\u00e1s informaci\u00f3n sobre setParams. Tambi\u00e9n puedes pasar par\u00e1metros iniciales a una pantalla. Si no especificas ning\u00fan par\u00e1metro al navegar a esta pantalla, se utilizar\u00e1n los par\u00e1metros iniciales. Tambi\u00e9n se a\u00f1adir\u00e1n a cualquier par\u00e1metro que pases a una pantalla. Los par\u00e1metros iniciales se pueden especificar con la prop initialParams : <Stack.Screen name=\"Details\" component={DetailsScreen} initialParams= {{ itemId : 42 }} /> \u00bfQu\u00e9 deber\u00eda pasar en los par\u00e1metros a una pantalla? \u00b6 Es importante comprender qu\u00e9 tipo de datos deben incluirse en los par\u00e1metros. Los par\u00e1metros son como opciones para una pantalla. Solo deben contener informaci\u00f3n para configurar lo que se muestra en la pantalla. Evita pasar todos los datos que se mostrar\u00e1n en la misma (por ejemplo, puedes un ID de usuario en lugar de un objeto de User). Evita tambi\u00e9n pasar datos que son utilizados por m\u00faltiples pantallas, dichos datos deber\u00edan estar en una store global . // \u00a1 No hagas esto ! navigation . navigate ( 'Profile' , { user : { id : 'jane' , firstName : 'Jane' , lastName : 'Done' , age : 25 , } , } ); Esto puede parecer conveniente y permite acceder a los objetos de usuario route.params.user sin ning\u00fan trabajo adicional. Sin embargo, esto se trata de un anti-patr\u00f3n. Los datos, como los objetos de usuario, deber\u00edan estar en una store global en lugar de en el estado de navegaci\u00f3n. De lo contrario, tendr\u00e1s los mismos datos duplicados en varios sitios. Esto puede generar errores, como que la pantalla de perfil muestre datos desactualizados, incluso si el objeto del usuario ha cambiado despu\u00e9s de la navegaci\u00f3n.","title":"React Navigation"},{"location":"react-navigation/#react-navigation","text":"Antes de entrar en materia con la navegaci\u00f3n a trav\u00e9s de nuestra aplicaci\u00f3n, la cual conseguiremos utilizando React Navigation, es de gran utilidad tener claro c\u00f3mo funciona la navegaci\u00f3n en un navegador web. En un navegador web, nuestro historial de navegaci\u00f3n act\u00faa como una pila de URLs. Los enlaces se crean con la etiqueta de anclaje ( <a> ) en HTML. Cuando el usuario hace clic en un enlace, la URL en la que nos encontr\u00e1bamos se env\u00eda a la pila del historial del navegador y navegamos a la p\u00e1gina enlazada. Si el usuario presiona el bot\u00f3n Atr\u00e1s, el navegador mostrar\u00e1 el elemento de la parte superior de la pila del historial, por lo que la p\u00e1gina activa pasar\u00e1 a ser la p\u00e1gina visitada anteriormente. React Native no tiene una idea incorporada de un historial global o pila de URLs como lo hace un navegador web; y es aqu\u00ed donde React Navigation entra en escena.","title":"React Navigation"},{"location":"react-navigation/#instalacion-de-dependencias","text":"Antes de nada, debemos instalar las dependencias esenciales para que React Navigation funcione correctamente. En la carpeta del proyecto, ejecuta el siguiente comando: expo install react - native - gesture - handler react - native - reanimated react - native - screens react - native - safe - area - context @react - native - community / masked - view Esto instalar\u00e1 las versiones de estas librer\u00edas compatibles con la versi\u00f3n de React Native en la que se encuentre nuestro proyecto. En React Navigation existen distintos tipos de navigators, pero en este taller nos centraremos en el Stack Navigator, que es el m\u00e1s similar al de un navegador web.","title":"Instalaci\u00f3n de dependencias"},{"location":"react-navigation/#stack-navigator","text":"El Stack Navigator de React Navigation nos provee de un mecanismo para navegar entre las distintas vistas de nuestra aplicaci\u00f3n y gestionar un historial de navegaci\u00f3n. Si tu aplicaci\u00f3n utiliza un \u00fanico stack navigator, ser\u00eda conceptualmente similar a la forma en la que un navegador gestiona su estado de navegaci\u00f3n - tu aplicaci\u00f3n mete o saca elementos de su pila de navegaci\u00f3n a medida que el usuario interact\u00faa con esta, y esto resulta en el usuario viendo distintas vistas. La diferencia respecto a un navegador web es que el stack navigator de React Navigation est\u00e1 provisto de los gestos y animaciones que ver\u00edas en una aplicaci\u00f3n de Android o iOS al navegar entre rutas. Para diferenciar entre los navigators de React Navigation, y un navegador web, no se traducir\u00e1 el concepto navigator cuando estemos hablando del primero de estos.","title":"Stack Navigator"},{"location":"react-navigation/#instalacion-de-la-libreria-del-stack-navigator","text":"Las librer\u00edas que hemos instalado hasta ahora son los cimientos del resto de navigators, y cada navigator en React Navigation tiene su propia librer\u00eda. Para utilizar el stack navigator, necesitaremos instalar @react-navigation/stack , ejecutando el siguiente comando. npm install @react - navigation / stack","title":"Instalaci\u00f3n de la librer\u00eda del stack navigator"},{"location":"react-navigation/#creacion-de-un-stack-navigator","text":"createStackNavigator es una funci\u00f3n que devuelve un objeto que contiene 2 propiedades: Screen y Navigator . Ambos son componentes de React que se utilizan para configurar el navigator. El Navigator debe contener elementos Screen como elementos hijo para definir la configuraci\u00f3n de rutas. NavigationContainer es un componente que administra nuestro \u00e1rbol de navegaci\u00f3n y contiene el estado de navegaci\u00f3n . Este componente debe envolver la estructura de todos los navigators. Por lo general, renderizamos este componente en la ra\u00edz de nuestra aplicaci\u00f3n, que suele ser el componente exportado desde App.js . // App . js import * as React from 'react' ; import { View , Text } from 'react-native' ; import { NavigationContainer } from '@react-navigation/native' ; import { createStackNavigator } from '@react-navigation/stack' ; function HomeScreen () { return ( < View style = {{ flex : 1 , alignItems : 'center' , justifyContent : 'center' }} > < Text > Home Screen </ Text > </ View > ); } const Stack = createStackNavigator (); function App () { return ( < NavigationContainer > < Stack . Navigator > < Stack . Screen name = \"Home\" component = { HomeScreen } /> </ Stack . Navigator > </ NavigationContainer > ); } export default App ; Si ejecutas este c\u00f3digo, ver\u00e1s una pantalla con una barra de navegaci\u00f3n vac\u00eda y un \u00e1rea de contenido gris que contiene el componente HomeScreen , definido justo antes de App. Los estilos de la barra de navegaci\u00f3n y el \u00e1rea de contenido son la configuraci\u00f3n predeterminada para un stack navigator, y aprenderemos c\u00f3mo configurarlos m\u00e1s adelante. El primer componente Screen que pasemos a nuestro stack navigator ser\u00e1 la ruta inicial . Prueba a crear un componente Details , que sea igual a Home pero cambiando el texto del contenido para diferenciarlos. A continuaci\u00f3n, crea un componente Screen y pasa el componente Details como prop. Ahora, prueba a poner este Screen en primer lugar, guarda el fichero y tu aplicaci\u00f3n deber\u00eda mostrar la vista de Details .","title":"Creaci\u00f3n de un Stack Navigator"},{"location":"react-navigation/#especificando-opciones-al-navigator","text":"Cada vista en el navigator puede tener sus opciones espec\u00edficas, como el t\u00edtulo que se renderiza en el encabezado. Estas opciones pueden pasarse como una prop options para cada componente Screen : <Stack.Screen name=\"Home\" component={HomeScreen} options= {{ title : 'Overview' }} /> A veces nos interesar\u00e1 especificar las mismas opciones para todas las vistas del navigator. Para ello, podemos pasar una prop screenOptions al navigator.","title":"Especificando opciones al navigator"},{"location":"react-navigation/#pasando-props-adicionales","text":"En caso de querer pasar props personalizadas a una vista, podemos conseguirlo de dos formas: Sometimes we might want to pass additional props to a screen. We can do that with 2 approaches: Utilizar React context y envolver el navigator con un provider de contexto para pasar datos a las vistas (recomendado). Utilizar un callback de renderizado en lugar de pasar un componente como prop: <Stack.Screen name= \"Home\" > {props => <HomeScreen {...props} extraData= {someData} /> } </Stack.Screen>","title":"Pasando props adicionales"},{"location":"react-navigation/#navegacion-entre-vistas","text":"Todo bien pero...\u00bfC\u00f3mo consigo navegar entre rutas de mi aplicaci\u00f3n? Vamos a ello. En la secci\u00f3n anterior, hemos definido un stack navigator con dos rutas ( Home y Details ), pero no hemos aprendido c\u00f3mo conseguir que un usuario navegue de Home a Details (aunque s\u00ed aprendimos c\u00f3mo cambiar la ruta inicial en nuestro c\u00f3digo, pero obligar a nuestros usuarios a clonar nuestro repositorio y cambiar la ruta en el c\u00f3digo para ver otra pantalla es posiblemente una de las peores experiencias de usuario que uno podr\u00eda imaginar). Si este fuera un navegador web, podr\u00edamos escribir algo como esto: <a href= \"details.html\" > Go to Details </a> O esto: <a onClick= {() = > { window.location.href = 'details.html'; }} > Go to Details </a> Haremos algo similar, pero en lugar de utilizar un objeto global window.location , usaremos el prop navigation del cual disponen nuestros componentes Screen de manera autom\u00e1tica. Observa el siguiente ejemplo: import * as React from 'react' ; import { Button , View , Text } from 'react-native' ; import { NavigationContainer } from '@react-navigation/native' ; import { createStackNavigator } from '@react-navigation/stack' ; function HomeScreen ({ navigation }) { return ( < View style = {{ flex : 1 , alignItems : 'center' , justifyContent : 'center' }} > < Text > Home Screen </ Text > < Button title = \"Go to Details\" onPress = {() => navigation . navigate ( 'Details' )} /> </ View > ); } // ... c\u00f3digo de la secci\u00f3n anterior Veamos esto con detalle: navigation: El prop navigation es pasado en cada uno de los componentes screen del stack navigator. navigate('Details') - llamamos a la funci\u00f3n navigate de la prop navigation (los nombres son algo confusos al principio) con el nombre de la ruta a la que queremos navegar. Si llamamos a navigation.navigate con un nombre de ruta que no hemos definido en un navigator, imprimir\u00e1 un error en las builds (compilaciones) de desarrollo y no pasar\u00e1 nada en las builds de producci\u00f3n. Dicho de otra manera, solo podemos navegar a rutas que hayan sido definidas en nuestro navegador, no podemos navegar a un componente arbitrario. Entonces, ahora tenemos una pila con dos rutas: 1) la ruta Home 2) la ruta Details . \u00bfQu\u00e9 pasar\u00eda si volvi\u00e9ramos a navegar a la ruta Details , desde la vista Details ? Pongamos que el c\u00f3digo de nuestro componente Details fuera el siguiente: function DetailsScreen({ navigation }) { return ( <View style= {{ flex : 1 , alignItems : 'center' , justifyContent : 'center' }} > <Text > Details Screen </Text> <Button title= \"Go to Details... again\" onPress= {() = > navigation.navigate('Details')} /> </View> ); } Si ejecutas este c\u00f3digo, notar\u00e1s que cuando tocas \"Go to Details...again\", \u00a1no hace nada! Esto se debe a que ya estamos en la ruta de Details. La funci\u00f3n navigate significa, en realidad, \"ir a esta ruta\", y si ya est\u00e1s ah\u00ed, tiene sentido que no haga nada. Supongamos que realmente queremos agregar otra vista de Details. Esto es bastante com\u00fan en casos en los que se pasa alg\u00fan dato \u00fanico a cada ruta (m\u00e1s adelante explicaremos c\u00f3mo hacerlo). Para hacer esto, podemos cambiar navigate a push . Esto nos permite expresar la intenci\u00f3n de agregar otra ruta, independientemente del historial de navegaci\u00f3n existente. < Button title = \"Go to Details... again\" onPress = { () => navigation . push ( 'Details' ) } /> Cada vez que llamamos a push , se a\u00f1ade una nueva ruta a la pila de navegaci\u00f3n. Cuando llamamos a navigate intenta encontrar una ruta existente con el nombre especificado, y solo pushea una nueva ruta en caso de no encontrarla en la pila. El encabezado proporcionado por el stack navigator incluir\u00e1 autom\u00e1ticamente un bot\u00f3n de retroceso cuando sea posible volver desde la pantalla activa (si solo hay una pantalla en la pila de navegaci\u00f3n, no hay nada a lo que se pueda volver, por lo que no hay bot\u00f3n de retroceso). En caso de necesitar este comportamiento en alg\u00fan otro sitio, puedes usar navigation.goBack(); function DetailsScreen({ navigation }) { return ( <View style= {{ flex : 1 , alignItems : 'center' , justifyContent : 'center' }} > <Text > Details Screen </Text> <Button title= \"Go to Details... again\" onPress= {() = > navigation.push('Details')} /> <Button title= \"Go to Home\" onPress= {() = > navigation.navigate('Home')} /> <Button title= \"Go back\" onPress= {() = > navigation.goBack()} /> </View> ); } Otro caso de uso com\u00fan es querer retroceder varias pantallas, por ejemplo, si tienes varias pantallas en una pila y quieres descartarlas todas para volver a la primera pantalla. Si quisi\u00e9ramos volver a Home , podr\u00edamos hacerlo usando navigate('Home') ( \u00a1no uses push ! Pru\u00e9balo y mira la diferencia). Otra alternativa ser\u00eda utilizar navigation.popToTop() , que te devuelve a la primera pantalla de la pila. function DetailsScreen({ navigation }) { return ( <View style= {{ flex : 1 , alignItems : 'center' , justifyContent : 'center' }} > <Text > Details Screen </Text> <Button title= \"Go to Details... again\" onPress= {() = > navigation.push('Details')} /> <Button title= \"Go to Home\" onPress= {() = > navigation.navigate('Home')} /> <Button title= \"Go back\" onPress= {() = > navigation.goBack()} /> <Button title= \"Go back to first screen in stack\" onPress= {() = > navigation.popToTop()} /> </View> ); }","title":"Navegaci\u00f3n entre vistas"},{"location":"react-navigation/#pasar-parametros-a-rutas","text":"Ahora que sabemos c\u00f3mo crear un stack navigator con algunas rutas, pasemos a ver c\u00f3mo podemos pasar datos a las rutas cuando navegamos hacia ellas. Hay dos pasos clave para esto: Pasar los par\u00e1metros a una ruta, contenidos en un objeto, como segundo par\u00e1metro de la funci\u00f3n navigation.navigate : navigation.navigate('RouteName', { /* los par\u00e1metros ir\u00edan aqu\u00ed here */ }) Leer los parametros en el componente de la pantalla utilizando route.params . function HomeScreen({ navigation }) { return ( <View style= {{ flex : 1 , alignItems : 'center' , justifyContent : 'center' }} > <Text > Home Screen </Text> <Button title= \"Go to Details\" onPress= {() = > { /* 1. Navigate to the Details route with params */ navigation.navigate('Details', { itemId: 86, otherParam: 'anything you want here', }); }} /> </View> ); } function DetailsScreen({ route, navigation }) { /* 2. Get the param */ const { itemId, otherParam } = route.params; return ( <View style= {{ flex : 1 , alignItems : 'center' , justifyContent : 'center' }} > <Text > Details Screen </Text> <Text> itemId: {JSON.stringify(itemId)} </Text> <Text> otherParam: {JSON.stringify(otherParam)} </Text> <Button title= \"Go to Details... again\" onPress= {() = > navigation.push('Details', { itemId: Math.floor(Math.random() * 100), }) } /> <Button title= \"Go to Home\" onPress= {() = > navigation.navigate('Home')} /> <Button title= \"Go back\" onPress= {() = > navigation.goBack()} /> </View> ); } Las pantallas tambi\u00e9n pueden actualizar sus par\u00e1metros, al igual que pueden actualizar su estado. el m\u00e9todo navigation.setParams permite actualizar los par\u00e1metros de una pantalla. navigation.setParams({ query: 'someText', }) Consulta la documentaci\u00f3n oficial para obtener m\u00e1s informaci\u00f3n sobre setParams. Tambi\u00e9n puedes pasar par\u00e1metros iniciales a una pantalla. Si no especificas ning\u00fan par\u00e1metro al navegar a esta pantalla, se utilizar\u00e1n los par\u00e1metros iniciales. Tambi\u00e9n se a\u00f1adir\u00e1n a cualquier par\u00e1metro que pases a una pantalla. Los par\u00e1metros iniciales se pueden especificar con la prop initialParams : <Stack.Screen name=\"Details\" component={DetailsScreen} initialParams= {{ itemId : 42 }} />","title":"Pasar par\u00e1metros a rutas"},{"location":"react-navigation/#que-deberia-pasar-en-los-parametros-a-una-pantalla","text":"Es importante comprender qu\u00e9 tipo de datos deben incluirse en los par\u00e1metros. Los par\u00e1metros son como opciones para una pantalla. Solo deben contener informaci\u00f3n para configurar lo que se muestra en la pantalla. Evita pasar todos los datos que se mostrar\u00e1n en la misma (por ejemplo, puedes un ID de usuario en lugar de un objeto de User). Evita tambi\u00e9n pasar datos que son utilizados por m\u00faltiples pantallas, dichos datos deber\u00edan estar en una store global . // \u00a1 No hagas esto ! navigation . navigate ( 'Profile' , { user : { id : 'jane' , firstName : 'Jane' , lastName : 'Done' , age : 25 , } , } ); Esto puede parecer conveniente y permite acceder a los objetos de usuario route.params.user sin ning\u00fan trabajo adicional. Sin embargo, esto se trata de un anti-patr\u00f3n. Los datos, como los objetos de usuario, deber\u00edan estar en una store global en lugar de en el estado de navegaci\u00f3n. De lo contrario, tendr\u00e1s los mismos datos duplicados en varios sitios. Esto puede generar errores, como que la pantalla de perfil muestre datos desactualizados, incluso si el objeto del usuario ha cambiado despu\u00e9s de la navegaci\u00f3n.","title":"\u00bfQu\u00e9 deber\u00eda pasar en los par\u00e1metros a una pantalla?"},{"location":"references/","text":"Referencias \u00b6 Documentaci\u00f3n de React Native | Facebook Documentaci\u00f3n de React Native Paper| Callstack Documentaci\u00f3n de React Navigation | Expo","title":"Referencias"},{"location":"references/#referencias","text":"Documentaci\u00f3n de React Native | Facebook Documentaci\u00f3n de React Native Paper| Callstack Documentaci\u00f3n de React Navigation | Expo","title":"Referencias"},{"location":"what-is-react-native/","text":"\u00bfQu\u00e9 es React Native? \u00b6 React Native es un framework de c\u00f3digo abierto para la creaci\u00f3n de aplicaciones m\u00f3viles, que fue creado por Facebook en 2015. React Native es muy parecido a React, solo que en lugar de utilizar componentes webs como bloques de construcci\u00f3n, utiliza componentes nativos. Los componentes web est\u00e1n formados por conjuntos de APIs de plataformas web que permiten a los desarrolladores crear elementos de la interfaz de usuario que sean sem\u00e1nticos, reutilizables y aislados. Pero, \u00bfqu\u00e9 son los componentes nativos? En el desarrollo de Android e iOS, una vista es el componente b\u00e1sico de construcci\u00f3n de interfaces de usuario, se trata de un peque\u00f1o elemento rectangular en la pantalla que puede usarse para representar texto, im\u00e1genes o para responder a entradas de un usuario. Incluso el elemento visual m\u00e1s peque\u00f1o en una aplicaci\u00f3n, como una l\u00ednea de texto, es un tipo de vista. Y como puedes imaginar, tambi\u00e9n existen vistas que incluyen m\u00e1s vistas dentro de ellas. En el desarrollo de Android, escribes vistas en Kotlin y Java, en iOS, utilizas Swift u Objective-C. Con React Native, puedes crear estas vistas con JavaScript, utilizando componentes de React. En tiempo de ejecuci\u00f3n, React Native crea las vistas correspondientes para Android o iOS de estos componentes. Los componentes de React Native son respaldados por las mismas vistas que Android o iOS, consiguiendo una apariencia, sensaci\u00f3n y rendimiento similar a cualquier otra aplicaci\u00f3n. Estos componentes respaldados por plataforma son conocidos como Componentes Nativos.","title":"\u00bfQu\u00e9 es React Native?"},{"location":"what-is-react-native/#que-es-react-native","text":"React Native es un framework de c\u00f3digo abierto para la creaci\u00f3n de aplicaciones m\u00f3viles, que fue creado por Facebook en 2015. React Native es muy parecido a React, solo que en lugar de utilizar componentes webs como bloques de construcci\u00f3n, utiliza componentes nativos. Los componentes web est\u00e1n formados por conjuntos de APIs de plataformas web que permiten a los desarrolladores crear elementos de la interfaz de usuario que sean sem\u00e1nticos, reutilizables y aislados. Pero, \u00bfqu\u00e9 son los componentes nativos? En el desarrollo de Android e iOS, una vista es el componente b\u00e1sico de construcci\u00f3n de interfaces de usuario, se trata de un peque\u00f1o elemento rectangular en la pantalla que puede usarse para representar texto, im\u00e1genes o para responder a entradas de un usuario. Incluso el elemento visual m\u00e1s peque\u00f1o en una aplicaci\u00f3n, como una l\u00ednea de texto, es un tipo de vista. Y como puedes imaginar, tambi\u00e9n existen vistas que incluyen m\u00e1s vistas dentro de ellas. En el desarrollo de Android, escribes vistas en Kotlin y Java, en iOS, utilizas Swift u Objective-C. Con React Native, puedes crear estas vistas con JavaScript, utilizando componentes de React. En tiempo de ejecuci\u00f3n, React Native crea las vistas correspondientes para Android o iOS de estos componentes. Los componentes de React Native son respaldados por las mismas vistas que Android o iOS, consiguiendo una apariencia, sensaci\u00f3n y rendimiento similar a cualquier otra aplicaci\u00f3n. Estos componentes respaldados por plataforma son conocidos como Componentes Nativos.","title":"\u00bfQu\u00e9 es React Native?"}]}